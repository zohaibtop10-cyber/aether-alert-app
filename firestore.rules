/**
 * @fileoverview Firestore Security Rules for the EcoBot application.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data protection by enforcing strict ownership-based access control for user-specific data.
 * Community-generated content (blog posts, articles, and data uploads) is publicly readable but restricted to owner-only writes.
 *
 * Data Structure:
 * - User profiles and chat history are nested under /users/{userId}.
 * - Alerts are stored in a top-level /alerts collection.
 * - Community content (blog posts, articles, data uploads) resides in top-level collections.
 *
 * Key Security Decisions:
 * - User listing is disabled.
 * - Ambiguous relationships default to owner-only access.
 * - Public read access is granted to community-generated content to foster knowledge sharing, but writes are strictly controlled.
 *
 * Denormalization for Authorization:
 * - Community content (blog posts, articles, and data uploads) requires an 'authorId' or 'uploaderId' field, respectively, to enable owner-only write rules.
 *   The rules validate that `request.auth.uid` matches this `authorId` or `uploaderId` on create and that the existing document's `authorId` or `uploaderId` matches on update and delete.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @example isSignedIn() == true if request.auth != null
     * @principle Authentication is required for secure access.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's authentication UID.
     * @example isOwner("someUserId") == true if request.auth.uid == "someUserId"
     * @principle Enforces user ownership for data access.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing resource.
     *              AND that the document exists.
     * @param {string} userId - The user ID to compare against the request's authentication UID.
     * @example isExistingOwner("someUserId") == true if request.auth.uid == "someUserId" && resource != null
     * @principle Enforces user ownership and document existence for data access.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow (create) - Authenticated user with matching UID can create their profile.
     * @allow (get, update, delete) - Authenticated user with matching UID can access and modify their profile.
     * @deny (create) - Unauthorized user attempts to create a profile with a mismatched UID.
     * @deny (list) - Listing users is not allowed.
     * @principle Enforces document ownership for writes and prevents unauthorized access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.email == request.auth.token.email;
      allow update: if isExistingOwner(userId) && request.resource.data.email == resource.data.email;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for chat history messages within a user's profile.
     * @path /users/{userId}/chatHistory/{messageId}
     * @allow (create, get, update, delete, list) - Authenticated user with matching UID can manage their chat history.
     * @deny (create, get, update, delete, list) - Unauthorized user attempts to access another user's chat history.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/chatHistory/{messageId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for alerts.
     * @path /alerts/{alertId}
     * @allow (none) - No direct client access; alerts are managed by backend services only.
     * @principle Restricts client-side access to alerts; managed server-side.
     */
    match /alerts/{alertId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for blog posts.
     * @path /blogPosts/{postId}
     * @allow (get, list) - Public read access for all blog posts.
     * @allow (create) - Authenticated user can create a blog post if the authorId matches their UID.
     * @allow (update, delete) - Only the author can update or delete their blog post.
     * @deny (create) - Unauthorized user attempts to create a blog post with a mismatched authorId.
     * @deny (update, delete) - Unauthorized user attempts to modify or delete another user's blog post.
     * @principle Public read, owner-only writes, and relational integrity for blog posts.
     */
    match /blogPosts/{postId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for articles.
     * @path /articles/{articleId}
     * @allow (get, list) - Public read access for all articles.
     * @allow (create) - Authenticated user can create an article if the authorId matches their UID.
     * @allow (update, delete) - Only the author can update or delete their article.
     * @deny (create) - Unauthorized user attempts to create an article with a mismatched authorId.
     * @deny (update, delete) - Unauthorized user attempts to modify or delete another user's article.
     * @principle Public read, owner-only writes, and relational integrity for articles.
     */
    match /articles/{articleId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for data uploads.
     * @path /dataUploads/{uploadId}
     * @allow (get, list) - Public read access for all data uploads.
     * @allow (create) - Authenticated user can create a data upload if the uploaderId matches their UID.
     * @allow (update, delete) - Only the uploader can update or delete their data upload.
     * @deny (create) - Unauthorized user attempts to create a data upload with a mismatched uploaderId.
     * @deny (update, delete) - Unauthorized user attempts to modify or delete another user's data upload.
     * @principle Public read, owner-only writes, and relational integrity for data uploads.
     */
    match /dataUploads/{uploadId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.uploaderId == request.auth.uid;
        allow update: if isSignedIn() && resource.data.uploaderId == request.auth.uid && resource != null;
        allow delete: if isSignedIn() && resource.data.uploaderId == request.auth.uid && resource != null;
    }
  }
}